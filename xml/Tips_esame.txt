MODELLAZIONE
1) Mettere sempre distruttore virtuale sulla classe base
2) Nei metodi di cancellazione (da un vettore per esempio)
	i)distruggere l'oggetto puntato dalla cella del vector con delete se necessario
	ii)non usare for ma while perchè l'iterazione va gestita in modo diverso, cioè
	quando si elimina tramite vector.erase(iterator) viene ritornato l'iteratore all'elemento
	successivo => it=vector.erase(it)
3) Capire se meglio usare list o vector
4) Non si possono istanziare oggetti di una classe astratta
5) i) begin e end devono ritornare per valore sennò dangling reference
   ii) differenza tra iterator e const_iterator è il ritorno const T& nel [] e nel * e forse anche nel ->
6) Un metodo const fa assumere all'oggetto di invocazione l'attributo const: all'interno del metodo,
   this passa da aver tipo A* a const A*=> il const si trasmette su tutti i suoi campi dati quindi
  a) oggetto: non si può modificare
  b) puntatore: diventa un puntatore costante del tipo: p * const obg, non si può spostare il puntatore
  c) vettore/contenitore: diventa un contenitore costante, quindi non si può modificarne le dimensioni,
     aggiungere nuovi oggetti, modificare i puntatori se è un vettore di puntatori. Si possono però
     modificare gli oggetti puntati dai puntatori, nel caso sia un vettore di puntatori. E' come
     diventasse const vector<obg * const>
7) Con const_iterator, ciò che è tra <...> di vector assume l'attributo di const, in questo
   caso è un puntatore a int quindi diventa un puntatore costante a int. E' come diventasse vector<int* const>
7.1) int * const tramite dynamic_cast può essere convertito a int *
8) Se si dichiara classe di SmartP, occhio che nel costruttore/di copia se si mette come argomento di default nullptr bisogna
   gestire la casistica
9) Se viene richiesto di confrontare l'uguaglianza tra due oggetti, bisogna ridefinire operator= su tutte le classi. Nella sottoclasse:
	i) Controllare se il parametro ha lo stesso tipo dinamico della sottoclasse tramite typeid(const Mp3&)==typeid(parametro) //non nella classe base
	ii) Richiamare l'operator= della classe base per confrontare il sottooggetto tramite this->classeBase::operator(f);
	iii) Confrontare i campi dati propri
10) operator* () ritorna ptr->info e operator->() ritorna &ptr->info (di tipo T* o const T*)
11) incremento prefisso: "const_iterator& operator++ ()", postfisso "const_iterator operator (int)", dev'essere possibile fare ++i=i++
12) quando c'è classe di puntatori smart, occhio che bisogna riferire tutto a it->ptr

COSA STAMPA
1) Quando un metodo viene "ereditato" da una classe perchè non presente nella derivata, il tipo "statico" è comunque quello della classe "base"
2) Quando si ha covarianza, il tipo di ritorno è comunque quello della classe base, anche se il metodo invocato a runtime è un altro
3) In particolare, quando si ha covarianza, il contratto (e tipo di ritorno) sono quelli della "classe statica" invocata, non della classe base se potenzialmente il suddetto metodo è un override di un metodo virtuale di una classe base ancora più in alto
4) Occhio nell'assegnazione e costruzione di copia di classi derivate: nell'ass: mettere chiamata a operator=della classe base passandogli
   il parametro. Simile per costruttore di copia, chiamare quello della classe base, passandogli il parametro
5) Una chiamata a funzione tramite dereferenziazione di puntatore polimorfo segue la chiamata polimorfa,
   tramite oggetto invece no
6) Se definisco un costruttore -> tutti gli altri spariscono tranne quello di copia
7) Definisco un costruttore di copia -> tutti gli altri spariscono
8) QUando chiamo un metodo in modo esplicito (es A::n()) anche se A::n() è virtuale, il binding è statico e viene scelta proprio quel metodo. Se essa chiama
   altri metodi però, il tipo dinamico rimane nelle chiamate successive
9) Un override può essere anche nella parte privata, non è un problema

ITERATORI:
const T& operator*() const {
      return ptr->info;
    }
    
    const T* operator->() const {
      return &(ptr->info);
    }
    
    constiterator& operator++() {
      if(ptr!= nullptr) {
	if(!pastTheEnd) { 
	  if(ptr->next==nullptr) {++ptr; pastTheEnd=true;}
	  else {ptr=ptr->next;}
	}
      }
      return *this;
    }
    
    constiterator& operator--() {
      if(ptr!=nullptr) {
	if(pastTheEnd) {--ptr; pastTheEnd=false;}
	else ptr=ptr->prev;
      }
      return *this;
    }
    
    bool operator==(const constiterator& x) const {
      return ptr==x.ptr;
    }

    bool operator!=(const constiterator& x) const {
      return ptr!=x.ptr;
    }
  };

  constiterator begin() const {
    return first;
  }
  
  constiterator end() const {
    if(last==nullptr) return nullptr;
    return constiterator(last+1,true);
  }


static bool isLess(nodo* d1, nodo* d2) {
    if(d2==nullptr) return false;
    // d2 NON e' vuota
    if(d1==nullptr) return true;
    // d1 e d2 NON vuote
    return d1->info < d2->info || 
      (d1->info==d2->info && isLess(d1->next,d2->next));
  }  

DILIST

if (!L) return l=nullptr;

	nodo * prec=new nodo(L->info);
	nodo * succ=prec;
	nodo * start=prec;

	while (L->next)
	{
		succ=new nodo(L->next->info,prec);
		prec->next=succ;
		L=L->next;
		prec=prec->next;
	}
	
	l=succ; 
	return start;

LISTA NORMALE
static nodo * copy(nodo * Ldc,nodo * & l)
{
	nodo * current=nullptr;
	nodo * inizio=nullptr;
	while (Ldc)
	{
		if (!inizio)
		{
			current=new nodo(Ldc->info);
			inizio=current;
		}
		if (Ldc->next)
		{
			current->next=new nodo(Ldc->next->info);
			current=current->next;
		}
		Ldc=Ldc->next;
	}
	l=current;
	return inizio;
}

